5612번 : 터널의 입구와 출구 

문제
상근이는 남산1호터널의 입구와 출구에서 1분에 통과하는 차량의 수를 조사했다. 이때, 터널에 차량이 가장 많이 있었을 때, 몇 대 있었는지 구하는 프로그램을 작성하시오.

입력
첫째 줄에 조사한 시간 n이 주어진다. 둘째 줄에는 조사를 시작할 때, 터널 안에 들어있는 차량의 수 m이 주어진다. 다음 n개 줄의 i번째 줄(i = 1 ~ n)의 정보는 조사를 시작한지 (i-1)분이 경과한 시점부터 i분 경과할 때 까지 1분에 입구를 통과한 차의 수와 출구를 통과한 차의 수이다. n은 10000보다 작거나 같고, 1분에 통과하는 차량의 수는 100이하이다.


출력
조사 시작하고 j분이 지난 시점 (j = 0~n)에서 터널 안에 있는 차량의 수를 Sj라고 하자. 이때, Sj의 최댓값을 출력한다. 만약, 터널 안에 있는 차량의 수가 0보다 작은 경우가 한 번 이라도 발생한다면 0을 출력한다.

---------------------------------------------------------------------------

이곳에서 필요한 정보만을 추출해보자
	1. 첫째 줄엔 조사한 시간 (입력 줄의 횟수)
	2. 둘째 줄엔 조사 시작 시 터널안의 차량 수 (A0)
	3. 세 번째 줄부터 (2+n)번째 줄 까지 n분에 (들어온 차량 수, 나간 차량 수)
	4. n분까지 각 분은 터널안의 차량 수 An이 존재할 것이다.
	5. 출력 : Ak (for 1<=k<=n)의 최댓값을 구해보자



---------------------------------------------------------------------------

이걸 어떻게 구현할까?
	Ak의 점화식을 구해보자
		Ak = A(k-1) + k분에 들어온 차량수 – k분에 나간 차량 수

	이걸 코드로 구현해보자
		-> 완료, project4의 question_5612참고




9226. 도깨비말

문제
도깨비말은 언어 유희 중 하나로, 글자를 특정 법칙에 따라 재구성하는 것을 말한다.
영어권에서는 피그라틴어라는 것이 있다. 주로 어린이들이 많이 쓰는 데, 남들에게 무슨 말인지 모르게 하기 위해 종종 쓴다. 
여기엔 규칙이 있는데, 맨 앞글자가 자음이 아닐때 까지 맨 앞 글자를 어미로 돌린 후 그 끝에 ay를 붙여서 완성한다. (예를 들면 frog는 ogfray이 된다) 만약 맨 앞자음이 없는 apple과 같은 경우는 끝에 ay만 붙여 appleay가 된다. 또는, 단어에 모음이 없는 경우에도 단어의 끝에 ay만 붙인다.
주어진 단어를 피그라틴어로 바꾸는 프로그램을 작성하시오.

입력
한 줄에 하나의 단어씩 주어진다. 그리고 마지막 줄에 #을 입력받고 끝낸다.

주어진 단어는 20자를 넘지 않고 공백없이 소문자로만 이루어져있다. 여기서 모음이란 'a', 'e', 'i', 'o', 'u' 를 말한다.

출력
한 줄에 하나씩 피그라틴어를 출력한다.



---------------------------------------------------------------------------
이 문제에서 출력하고자 하는 문자열의 규칙을 찾아보자
1. 맨 앞 글자가 자음이 아닐 때 까지 맨 앞 글자를 어미로 돌린 후 그 끝에 ay를 붙여서 완성한다. 
2. 만약 맨 앞 자음이 없는 apple과 같은 경우는 끝에 ay만 붙여 appleay가 된다. 
3. 단어에 모음이 없는 경우에도 단어의 끝에 ay만 붙인다.

이 조건을 통해 원하는 문자열을 얻으려면 다음과 같은 스텝이 필요하다
1. 문자열에서 가장 맨 처음의 모음을 찾는다. 
2. 만약 모음이 있다면(이때 모음의 위치를 k라고 하자) 1~k-1에 해당하는 문자열을 n+1 ~ 뒤에 연결한다
	2-1. 만약 모음이 없다면 이를 건너뛴다
3. 문자열의 맨 뒤에 ay를 붙이고 출력한다.





크로스워드 만들기

문제
창영이는 크로스워드 퍼즐을 만들려고 한다.

두 단어 A와 B가 주어진다. A는 가로로 놓여야 하고, B는 세로로 놓어야 한다. 또, 두 단어는 서로 교차해야 한다. (정확히 한 글자를 공유해야 한다) 공유하는 글자는 A와 B에 동시에 포함되어 있는 글자여야 하고, 그런 글자가 여럿인 경우 A에서 제일 먼저 등장하는 글자를 선택한다. 마찬가지로 이 글자가 B에서도 여러 번 등장하면 B에서 제일 처음 나오는 것을 선택한다. 
첫째 줄에 두 단어 A와 B가 주어진다. 두 단어는 30글자 이내이고, 공백으로 구분되어져 있다. 또, 대문자로만 이루어져 있고, 적어도 한 글자는 두 단어에 포함되어 있다.

출력
A의 길이를 N, B의 길이를 M이라고 했을 때, 출력은 총 M줄이고, 각 줄에는 N개 문자가 있어야 한다. 문제 설명에 나온 것 같이 두 단어가 교차된 형태로 출력되어야 한다. 나머지 글자는 '.'로 출력한다.


이 문제는 두가지 문제로 나눌 수 있다.
1. 크로스워드 만들기
2. 크로스워드 출력하기

1. 크로스워드 문제 만들기
	-0. String A, String B가 있다고 가정하자
	-1. String A와 String B에 공통적으로 들어가는 문자와 그 문제의 위치를 저장한다
	-2. 그 문자 중 A에서 가장 낮은 위치의 문자를 기억한다
	-3. B에서 이 문자에 해당하는 가장 낮은 위치를 기억한다
	-4. 크로스워드 제작 완료

2. 크로스워드 출력 문제
	-0. 저장해둔 A문자열의 공통 문자의 위치를 a, B는 b라고 하자
	-1. 1번째 행부터 a-1번째 행까지 .을, a번째에 B의 문자를, a+1 행부터 끝 행까지 .을 출력한다
	-2. b열에 문자열 A를 출력한다.

공통된 문자를 찾는 방법?
	모든 문자에 대해 서로 문자의 위치를 찾는다? 
		-> 26*2만큼의 저장 공간 필요 => 낭비가 너무 심할 것 같다.
		-> 최대 M + N시간이 걸린다
	그럼 A의 첫 문자부터 B에 해당하는 문자가 있는지 확인한다?
		-> 별도의 필요 저장공간이 적다
		-> 최대 M*N의 시간이 걸린다?

A방식이 더 좋을 것 같다.

완성
그런데 코딩하던 도중 지식이 늘었다.
if
	if
else if
와 같이 코딩하려는 의도가 있었으나, 뒤의 else if 부분이 처리가 되지 않았다.
그 이유를 살펴보니 다음 문장이
if
	if
	else if
와 같이 실행되었기 때문이다.
왜 그런가 하고 보니 맨 처음 if 부분에 괄호를 쓰지 않았기 때문이였다.
그래서
if{
	if}
else
와 같이 해주니 해결이 되었다.

** c언어가 키워드에 대해 한 줄을 어떻게 판단하는지 더 조사해봐야 겠다.

















2160. 그림 비교

문제
N(2≤N≤50)개의 그림이 있다. 각각의 그림은 5×7의 크기이고, 두 가지 색으로 되어 있다. 이때 두 가지의 색을 각각 ‘X’와 ‘.’으로 표현하기로 하자. 이러한 그림들이 주어졌을 때, 가장 비슷한 두 개의 그림을 찾아내는 프로그램을 작성하시오. 두 개의 그림에서 다른 칸의 개수가 가장 적을 때, 두 개의 그림이 가장 비슷하다고 하자.

입력
첫째 줄에 N이 주어진다. 다음 5×N개의 줄에 7개의 문자로 각각의 그림이 주어진다.

출력
첫째 줄에 가장 비슷한 두 그림의 번호를 출력한다. 그림의 번호는 입력되는 순서대로 1, 2, …, N이다. 번호를 출력할 때에는 작은 것을 먼저 출력한다. 입력은 항상 답이 한 가지인 경우만 주어진다.


결과적으로 각 그림 (5*7 테이블)의 각 줄의(5칸) 각 칸을 비교하여 차이가 가장 적은 두 그림의 index를 비교하면 된다.

배열로 하면 끝이지만 해보고 싶은게 있어서 vector을 사용했다.

vector<string[5]>로 각 picture를 저장하고 싶었으나 불가능 했다.
그래서 방법을 찾아보았고, 다음과 같은 코드로 대체 가능함을 알게 되었다.
vector<vector<string>> 이렇게 하면 그림의 개수와 행과 열을 모두 dynamic하게 쓸 수 있었다.

1번째 vector의 원소 : 하나의 그림
2번째 vector의 원소 : 하나의 하나의 행
3번째 string의 원소 : 하나의 칸(열)

그런데 왜 배열을 vector로써 사용할 수 없는것일까?
찾아보니 배열은 대입연산자(즉, =)를 통해 값을 복사할 수 없기 때문 이라고 한다.
생각해보면 당연하다. 원소를 push하기 위해서는 그 원소를 대입연산자로서 ‘복사’해야 하는데 배열은 불가능하기 때문이다 
그러면 배열을 위해 =이 아닌 새로운 대입 연산자를 만들어 사용하면 되지 않느냐? 라고 할수 있지만, STL특성상, Type이 정해지지 않은 상태로 작성되어졌기 배열을 고려할 수 없고, 그저 대입 연산자를 통해 STL이 작성된 것이다.
이를 해결할 수 있는 방법이 또 무엇이냐? 라고 물을 수 있다.
아까 말했듯이, 대입연산자를 지원하는 데이터 타입을 원소로 하면 되는 것이다.
따라서 vector<vector<string>>이 가능한 것이고, vector<struct>가 가능한 것이다.
1996. 지뢰 찾기


문제
지뢰 찾기 map은 N*N의 정사각형 모양으로 각 칸에는 숫자가 들어가 있거나 지뢰가 들어가 있다. 빈 칸에는 숫자 0이 들어있다고 생각하자.

map의 어떤 칸에 적혀 있는 숫자는, 그 칸과 인접해 있는 여덟 개의 칸 중에서 지뢰가 들어 있는 칸이 몇 개인지를 나타내 준다. 물론 인접한 칸이 map 내부에 있는 경우에 대해서만 생각하면 된다. 

이번 문제 조금 업그레이드 된 지뢰 찾기로, 한 칸에 한 개의 지뢰가 있는 것이 아니고, 한 칸에 여러 개(1 이상 9 이하)의 지뢰가 묻혀 있는 게임이다. 따라서 map의 어떤 칸에 적혀 있는 숫자는, 그 칸과 인접해 있는 여덟 개의 칸들에 들어 있는 지뢰의 총 개수가 된다.

이미 windows 지뢰찾기 같은 것을 마스터한 영식이는, map에서 지뢰에 대한 정보만이 주어졌을 때, 영식이는 map을 완성하고 싶다고 한다. N과 지뢰의 위치가 주어졌을 때, 영식이를 도와서 지뢰 찾기 map을 완성하는 프로그램을 작성하시오.

입력
첫째 줄에 N(1≤N≤1,000)이 주어진다. 다음 N개의 줄에는 지뢰 찾기 map에 대한 정보가 주어지는데 '.' 또는 숫자로 이루어진 문자열이 들어온다. '.'는 지뢰가 없는 것이고 숫자는 지뢰가 있는 경우로 그 칸의 지뢰의 개수이다. 한 줄은 N개의 문자로 이루어져 있다.

출력
N개의 줄에 걸쳐서 완성된 지뢰 찾기 map을 출력한다. 지뢰는 '*'로 출력하며. 10 이상인 경우는 'M'(Many)으로 출력하면 된다. map은 숫자 또는 'M' 또는 '*'로만 이루어져 있어야 한다.


결국에는 묻어진 지뢰의 개수와 칸을 바탕으로 나머지를 완성하면 되는 것!
그럼 한 칸이 포함해야 할 칸들의 점화식을 세워보자.
A(m,n)이라고 할 때, A(m-1~m+1, n-1~m+1) // 자신 제외!
이를 코드화 해서 사용해보자.
