
9095. 1, 2, 3 더하기
입력 : 정수 n
출력 : 경우의 수

n을 1, 2, 3의 합으로 나타낼 수 있는 경우의 수를 찾아야 한다.
그렇다면 이 경우의 수를 찾기 위해선 1,2,3을 이용해 합을 도출해 낼 수 있어야 한다.
그렇다면 n을 작은 문제로 나눠보자.
x(n) = x(n-1) + x(n-2) + x(n-3) // when x(1) = 1, x(2) = 1, x(3) = 1
// 해답 1 : DP로 문제를 해결한다.

 다른 방법에 대해서 생각하고 싶다. 이 점화식을 이용해서 x(n)을 구하는 식을 찾아보자

이걸 일반화 시켜주면 점화식이 나타난다.
 ... 만들어 보자 점화식





---------------------------------------
11726. 2×n 타일링

2xn 직사각형의 경우, n이 다음과 같이 case가 나뉜다.
if n == 홀수
  -> x(n) = x(n-1) // 어차피 반드시 하나가 세로 2*1짜리로 채워야 하므로
		// 결국 홀수도 짝수 case로 풀린다
		// 하지만 위치는 불분명하다.
if n == 짝수
 -> x(n) = ? 


그냥 이걸 일반적인 식으로 나타낸다면,
x(n) = x(n-2) (// 2*2블록인 경우) + x(n-2) (// 2*1 가로블록 * 2인 경우)  + x(n-1) (// 2*1 세로블록인 경우)  
x(n) = 2*x(n-2) + x(n-1)이다. // x(1) = 1, x(2) = 3
이걸 DP로 풀면 ㅇㅋ?
x(3) = 2*x(1) + x(2) = 2 + 3 = 5	

이걸 이용해서 점화식을 일반화 시켜보자.
x(8) = x(7) + 2*x(6)
      = 3*x(6) + 2*x(5)
      = 5*x(5) + 6*x(4)
      = 11*x(4) + 10*x(3)
      = 21*x(3) + 22*x(2)
      = 43*x(2) + 42*x(1)

129 + 42 = 171

점화식을 보면 진짜 쉬워보인다.
한번 생각해보자면 결국에는 두 계수 사이에 차이는 1뿐이다.
n이 짝수인 항의 계수가 1 더 크다.
// 좀있다가 한번 찾아보자


점화식을 이용해 일반화 시켜서 문제를 풀어보려고 했으나....
2*1 세로블록의 위치에 따라서 생각해야할게 너무 많아져 포기했다.
이 새로블록의 case에 따라 문제가 다양해지기 때문에 머리가 너무 복잡해졌다.


// 와하우, 이거 그냥 문제를 2차원에서 1차원으로 끌어 내려서 풀 수도 있구나
// 만약에 이 문제를, 1차원 적으로 바라본다면, 길이가 1인 블록과(즉 세로), 길이가 2인 블록(즉 가로*2 혹은 2*2 하나)으로 길이가 n인 블록을 만드는 것이므로 아까 문제와 동일하게 덧샘으로 풀 수 있다.
// 초기화엔 manset이 더 빠르다



---------------------------------------
10844. 쉬운 계단 수

10 21 ... 98 9개
12 13 ... 89 8개

17개


n번째 자리의 수와 n-1~1번째 자리수로 나누어 생각해보자.
n번째 자리수가 1일 때 -> n-1 번째 자리수는 0 + n-1번째 자리수 2 =>  n[n][1] = n[n-1][0] + n[n-1][2]
n번째 자리수가 2일 때 -> n-1 번째 자리수는 1 + n-1번째 자리수 3 =>  n[n][2] = n[n-1][1] + n[n-1][3] 
n번째 자리수가 3일 때 -> n-1 번째 자리수는 2 + n-1번째 자리수 4 =>  n[n][3] = n[n-1][2] + n[n-1][4]
n번째 자리수가 4일 때 -> n-1 번째 자리수는 3 + n-1번째 자리수 5 =>  n[n][4] = n[n-1][3] + n[n-1][5]
n번째 자리수가 5일 때 -> n-1 번째 자리수는 4 + n-1번째 자리수 6 =>  n[n][5] = n[n-1][4] + n[n-1][6]
n번째 자리수가 6일 때 -> n-1 번째 자리수는 5 + n-1번째 자리수 7 =>  n[n][6] = n[n-1][5] + n[n-1][7]
n번째 자리수가 7일 때 -> n-1 번째 자리수는 6 + n-1번째 자리수 8 =>  n[n][7] = n[n-1][6] + n[n-1][8]
n번째 자리수가 8일 때 -> n-1 번째 자리수는 7 + n-1번째 자리수 9 =>  n[n][8] = n[n-1][7] + n[n-1][9]
n번째 자리수가 9일 때 -> n-1 번째 자리수는 8 =>  n[n][9] = n[n-1][8]
이걸 배열의 식으로 바꾼 다음, 배정한다
	// 예외 처리를 해야 한다는게 중요할거 같다

이를 2차원 배열로 생각해보자
2차원 배열을 다음과 같이 정의한다고 한다면
// X[n][k] = n번째 자리수 중, 맨 앞자리 수가 k일 때 도출되는 계단 수 // x[n+1][0] 은 자리수가 n일 때 도출되는 총 계단 수
그렇다면, 
자리수가 n일 때 도출되는 총 계단 수(즉, x[n+1][0]) 
	= x[n-1][0] + x[n-1][1] + 2(x[n-1][2] .... + x[n-1][8]) + x[n-1][9] 이다.
이를 n = 2일때라고 도출 생각해본다면
1 + 1 + 2 (1+1+1.... +1) + 1 = 1 + 1 + 1 + 2*7 = 14 + 3 = 17
와 같이 정답이 도출됨을 알 수 있다.
이를 DP로써 풀면 될거 같다.


---------------------------------------
1309. 동물원

가로로  두칸 세로로 N칸이래
여기에 사자들이 마주치지 않게 넣으래
사자가 몇마리 있냐에 따라서 경우의 수는 천차 만별일 것이야
세로의 크기가 N일때 사자가 들어갈 수 있는 경우의 수는  0 ~ N 일거야
그럼 만약에 이렇게 사자가 들어가 있는 수가 다음 칸의 사자가 들어갈 경우의 수에 영향을 미칠 수 있을까?
YES -> N-1번째 칸에 사자가 없다면 난 두 칸 모두 넣을 수 있지,
         그런데 사자가 있다면 반드시 한칸에 밖에 못넣어. (어디인지는 자동으로 설정되므로 생각할 필요가 없지?)

그럼 결국에는 1~N칸까지 사자를 배치할 경우의 수를 따지기 위해서는 N-1칸에 사자가 있는 경우와 없는 경우를 저장해야 한다는 거네?

배열을 다음과 같이 정의한다고 할 때 점화식을 구해보자.
// 사자가 N칸에 없는 경우 : X[N][0] = X[N-1][0] + X[N-1][1] 
// 사자가 N칸에 있는 경우 : X[N][1] = 2 * X[N-1][0] + X[N-1][1]
// 2*N칸에 사자를 배치할 수 있는 경우의 수 = X[N][0] + X[N][1]

이 점화식을 이용해서 문제를 해결하면 될 것 같다.
그런데, 초기값을 어떻게 지정해 주어야 할까?
입력에 대해서 N(1≤N≤100,000)이라고 문제에 주어져 있기 때문에 다음과 같이 초기값을 지정해 주면 될 것 같다
X[N][0] = 1, X[N][1] = 1

이제 이걸 bottom-up 방식으로 풀면 해결!

한번 직접 해보자.

X[1][0] = 1
X[1][1] = 2

X[2][0] = 2 + 2 = 4
X[2][1] = 2 + 2 = 4


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTcxNDI3NzUyM119
-->