# 장고 뷰의 기본 개념


## **1. 장고 개념 키워드**
1. model
  장고의 모델 == 워크시트
  데이터 베이스의 인터페이스
  비지니스 모델이 저장됨

2. view
  http request요청을 처리하여 http response를 리턴해 주는 역할
  reteurn render(request, html, {elements for html})

3. template
  복잡한 문자열의 조합하여 일반적으로 html을 만드는 것 대신 장고 탬플릿을 이용해서 를 더 간단하게 html을 만들어 준다
  View에서 전달 받은 elements를 바탕으로 view(html)을 만들어 주는 것

4. admin
  심플한 데이터베이스 레코드(데이터) 관리 UI
  장고에 미리 만들어진 페이지

5. logging
  로깅

6. form
  유저가 입력한 정보를 서버에 전송해주는 formm 페이지
  입력된 정보가 DB에 적용될 수도 있다.

// 이제부터 이 키워드들을 이용해서 장고의 기본 개념을 설명하고자 한다.



---
우선 장고가 어떻게 유저가 요청하는 정보를 어떻게 전달하는지 알아보자

##장고의 기본 구조

![django_1](./img/장고 기본 구조.png)

---
  1. 클라이언트가 url 입력 
  
  2. 서버가 받아서 URL에 해당하는 올바른 뷰로 전달
    프로젝트/urls.py의 설정 중, url conf(url을 함수와 연결시켜주는 기능)을 통해 뷰와 연결됨
    
  3. 장고 모델을 통해 데이터 베이스와 프레임워크가 응답을 주고 받음
  
  4. 장고 모델이 뷰로 데이터를 줌
  
  5. DB로 부터 얻은 데이터와 뷰와 연결된 html(템플릿)을 바탕으로. 완성된 html을 클라이언트에게 리턴해줌
---



---
이제 장고가 어떻게 클라이언트의 요청을 처리하는지 봤으니 장고가 어떻게 앱을 관리하는지 살펴보자
## Preivew 새로운 장고 앱을 생성할 때 해야 하는 작업
  1. 앱생성
  2. 앱/urls.py 파일 생성, url 패턴 적용
  3. 프로젝트/urls.py에 include를 통해 site의 url중, shop의 url을 앱/urls.py로 넘긴다
  4. 프로젝트/settings.py안의 INSTALLED_APPS에 새로운 앱을 등록한다
  
이제부터 나열된 것들이 무엇인지 천천히 함께 알아보자 

##장고 앱이란?
  목적에 맞게 만들어진 장고 앱
  "python manage.py startapp 이름" 을 통해 "이름"에 해당하는 빈 장고앱을 만들어 준다.
  장고 앱 분리의 필요성 :  앱의 재사용을 위해. (만약 블로그를 장고앱의 형태로 만들어 둔다면 블로그앱을 필요시에 재사용 할 수 있다)
	따라서 기능의 재사용성을 기준으로 장고 앱을 구성해야 한다

##장고 앱의 주의점
  하나의 앱 이름만 사용해야 한다. 
  장고 앱을 사용하기 위해선 settings.py에 이 장고앱을 등록시켜야 한다 (installed apps)
	  (왜 이와 같은 작업을 거쳐야 하는가? -> 본래 하나하나 등록해야 할 앱의 모델, 템플릿, static등이 이 작업을 거치면 자동으로 등록되므로, 반드시 이를 등록시켜줘야 한다)
  앱은 고유한 models를 갖는다 
    -> 하나의 파일에 앱의 모든 정보를 때려 박기엔 너무 많다면 models.py를 나눠 관리할 수 있다.
    -> how? 
	    하나의 models.py 대신 다양한 model을 가진 models폴더로 모델을 구축
         (예시 : items.py, review.py + (__init__.py [모든 모델을 import해서 하나로 만들어 주는 파일])로 구성하여 하나의 models를 이용하는 것과 같은 효과를 준다)
	        // 패키지 개념, 나중에 앱이 복잡해질때 폴더(패키지)로서 모델을 구축하자. 

---
이렇게 생성된 장고 앱에 url이 들어온다면 url에 해당하는 view가 호출된다고 했는데, 장고는 어떤 view가 연결됐는지 어떻게 알까?
바로 ** url dispatcher ** 을 통해 url에 해당하는 view를 찾는다

## url dispatcher과 정규 표현식
1. url dispatcher란?
  url dispatcher과 정규표현식을 통해 url과 view를 매칭한다

2. 정규 표현식이란? : 문자열의 패턴, 규칙, rule를 정의하는 방법
   왜해 이걸 쓰는거지? : 문자열의 검색, 치환을 간편하게 처리할 수 있으므로 
   (예시 : www.ex.com/item 에서 www.ex.com/<string>과 같이 하면 장고가 "item"을 바로 검색하여 변수에 치환할 수 있다)


3. 정규 표현식의 문법
  -0. 기본 개념 : [하나의 글자에 대한 패턴]과 [연속된 출연 횟수 지정]을 통해 문자열을 표현함  
  
  -1. [하나의 글자에 대한 패턴]을 나타내는 방법
    -> “[가능한 문자들의 나열]” 혹은 “[시작_문자-종료_문자]” 혹은 특수한 기호 (ex: “\d”)
    
  -2. 이렇게 만든 하나의 가능한 문자를 반복횟수를 지정함으로써 문자열로 만들어준다
    -> r“\d{횟수}” 혹은 r“\d특수기호” (ex: r“\d+”)


4. url패턴을 더 간결하게 나타내는 방법 **"path"**
  path를 사용하면 url(정규표현식, 함수)를 더 간소화할 수 있다.
  ex: url(r^articles/?P<year>[0-9]{4}/$’, views.~~) (여기서 ^는 “를, $는 ”를 의미한다)
	  -> path(‘string/<type:name>/’, views.~~)와 같이 편하게 사용할 수 있게 되었다.
  ** 하지만 문제는 path를 쓴 경우와 쓰지 않은 두 경우는 약간 다르다 **
    -> (왜냐하면 첫 번째 url은 반드시 4개의 데이터가 들어갈 것이고, 두 번째는 몇개의 문자가 들어와도 데이터가 들어가기 때문이다)
	 때문에 이를 **re_path**로써 해결 가능하다
	  ->re_ppath(‘url과 똑같이’)


5. path converter?
  path는 string이므로 전달되는 변수의 데이터 타입은 string이다.
	  => path converter를 통해 string인 path를 특정 type의 데이터로 변환할 수 있다.
	  => url의 특정 부분을 xxxx타입 변수로 변환하여 view에 전달을 하는 예시 
      -> ( ... <xxxx:val_name>, view.~~~)
  장고 기본 제공 path converter (아래에 "Converter -> 정규 표현식" 의 형태로 나타낼 것이다.)
    0. ("Converter -> 정규 표현식")
	  1. string -> r“[^/]+”
	  2. int -> r“[0-9]+”
	  3. slug -> r“[-a-zA-Z0-9_]+” (맨 앞의 –와 맨 뒤의 _는 하나의 문자를 의미한다)
	  4. path -> r“.+”


6. 커스텀 path converter (path를 data로 변환해주는 커스텀 컨버터)
  이를 구현하기 위해서는 다음과 같은 작업을 거쳥야 한다
    1. 커스텀 path converter class를 만든다
    2. 그 class에 to_python(self, value)를 구현한다. (url -> data)
    3. 그 class에 to_url(self, value)함수를 구현한다. (data -> url)
    4. register_converter(class, ‘expression’)으로 커스텀 path converter 클래스를 등록해준다.


위에 서술한것과 같이 장고앱을 만들면, url의 패턴과 views를 연결해 주어야 한다.
// url pattern 또한 이전의 model과 같이 패턴을 앱마다 url의 pattern을 소등분하고, 이를 합쳐서 사이트의 전체 url patter을 구성하는 방법도 있다

---

## View

“1개의 HTTP요청 -> 1개의 뷰를 호출” 임은 저번에 url dispatcher시간에 배웠다.
이렇게 호출된 view라는 것은 무엇일가?


1. 장고의 View란? : request를 처리하여 response를 리턴하는 호출 가능한 객체!
  이 개체를 통해서 뭘 하려고? => HTTP요청을 처리해서 의도한 Response를 리턴하려고!
  여기서 호출 가능한 객체라는 것은 무엇을 의미하는 걸까?
	  => 함수 기반 뷰 : 장고 뷰의 기본으로써 함수 자체가 호출 가능한 객체이다
	  => 클래스 기반 뷰 : 클래스가를 만들고, 그 클래스의 view를 통해 호출 가능한 객체를 생성하고 리턴하는 것이다. 
      (클래스 기반 뷰를 왜 쓰는가? : 메카니즘이 가릴 수 있기 때문 -> 장점이자 단점)
        // 장점 : 간편한 사용, 보안
        // 단점 : 내부 구조 파악의 어려움


2. View 호출 시 필요한 인자?
  1. HttpRequest 객체 (현재 요청에 대한 모든 정보를 담고 있는 것)
  2. Url로부터 Captue된 문자열들 (이건 하나 이상이 될 수도 있다. 어떻게 값을 capture하는지에 따라 값의 형이 다르기 때문에 이를 고려 해 두어야 한다.)


3. view 호출의 리턴값 
  -> 반드시 HttpResponse!! (django.shortcuts.render를 통해 템플릿 응답이 가능하다!)
 	  추가) 파일 like 객체 (근데 str 문자열을 str을 utf8로 장고가 자동 인코딩 해주니까 인코딩 안해도 된대 [이게 뭐지?]) -> 이것도 결국 HttpResponse이므로 똑같다!
	  (HttpResponse(파일like객체 or str객체 or bytes객체))
	  ** 이 “파일like객체 or str객체 or bytes객체”가 뭔지 다시한번 더 알아볼 필요가 있다! **


4. 장고 request와 response의 기본적인 속성
  // 장고 request의 속성
---
  from django.http import HttpResponse

  def index(request):
  	# 주요 request 속성
  	request.method # 'GET', 'POST', etc.
  	request.META
  	request.GET, request.POST, request.FILES, request.body 
  		(get은 post, files등일 경우에도 속성이 존재할 수 있다.)
      (각 속성들은 요청에 해당하는 정보들을 포함한다)
  
	  content = '''
	  <html>…</html>
    ''' # 문자열 혹은 이미지 등
  	response = HttpResponse(content)
  	response.write(content) # file-like object
  	response['Custom-Header'] = 'Custom Header Value'
  	return response
---
5. 함수 기반 VIEW의 직접적인 예시 코드
---
  from django.shortcuts import render
  from shop.models import Item

  def item_list(request):
	  qs = Item.objects.all() //  Quryset을 통해 서버에서 아이템 목록을 가져올 준비만 하는 것
	  return render(request, 'shop/item_list.html', { // render을 통해 http response를 만들어 냄!
	  'item_list': qs, // 실제로 데이터를 가져오는 단계
	  })
---
  ** 쿼리셋이라는 것이 무엇인지 자세히 알아봐야 함 **
    render : request와 html(템플릿)과 그리고 database(쿼리셋)을 쓰까서 response를 만들어 내는 것!


6. 클래스 기반 뷰의 예시
---
  from django.shortcuts import render
  from shop.models import Item

  class GenericListView:
	  def __init__(self, model_cls):
		  self.model_cls = model_cls

	  def get_list_name(self):
		  return '{}_list'.format(
		    self.model_cls._meta.model_name)

	  def get_template_name(self):
		  return self.model_cls._meta.app_label + '/' + \
			  self.get_list_name() + '.html'

	  def get_queryset(self):
		  return self.model_cls.objects.all()

    def get_context(self):
		  return {
			  self.get_list_name(): self.get_queryset(),
		  }

	  def __call__(self, request):
		  context = self.get_queryset()
		    return render(request, self.get_template_name(),
			    self.get_context())

---
  item_list = GenericListView(Item)
---

  위와 같이 클래스 기반 뷰를 작성하면 아래와 같이 클래스를 호출하여 view를 가져올 수 있다.
  왜 이렇게 하냐? => 클래스의 객체를 생성하면 __call__이 호출되고, 이 함수가 아까 본 "함수 기반 뷰의 예시"와 같은 기능을 하는 것이다!


7. 라이브러리를 통한 view 생성
  근데 이걸 그냥 이렇게 복잡하게 하지말고 라이브러리를 사용하면 개편하게 view를 만들 수 있다
  django.views.generic import ListView의 ListView클래스를 통해 view를 만들 수 있다
  그리고 클래스의 as_view함수를 통해 view를 만들어 보자
  item_list = ListView.as_view(model=item) 과 같이 해주면 아무것도 안해도 바로 끝나는 것!
  그럼 이 model에 대한 view가 만들어 진다!
  ** 근데 html과 쿼리셋의 변수를 어떻게 알지? **
	  => 변수 이름인 "item_list"이름으로 앱에 대한 html 템플릿과 DB의 데이터에 접근한다.



8. 추가 공부
  지금까지 response를 만드는 View에 대해 공부해봤는데 이 View내부에서 문자 타입 response뿐만 아니라 다양한 response를 얻을 수 있다. (MAME type이라고 검색하면 많이 나온대) 
  지금부터 그걸 어떤게 있는지 알아보자
  pandas(데이터 전처리용 라이브러리)를 통한 -> excel 응답 생성
  pilow()를 통한 -> 이미지 응답 생성



9. HTTP 상태코드
  status_code(상태코드)란? 
	  => 404 error와 같이 각 httpResponse 클래스마다 고유한 status_code가 할당되어야 한다. (rest api를 만들 때 특히 유용해다)
    => ** rest api가 뭐지? **
	응답에 대해서 status_code를 케이스마다 분기하여 어느 부분에서 실패했는지 알 수 있다.

  아래는 대표적인 상태코드 들이다
  • 200번대 : 성공
	  • 200 : 서버가 요청을 잘 처리했다.  OK
	  • 201 : 작성됨. 서버가 요청을 접수하고, 새 리소스를 작성했다.

  • 300번대 : 요청을 마치기 위해, 추가 동작을 취해야 한다. • 301 : 영구 이동, 요청한 페이지가 새 위치로 영구적으로 이동했다.
	  • 302 : 임시 이동, 페이지가 현재 다른 위치에서 요청에 응답하고 있지만, 요청자는 향후 원 래 위치를 계속 사용해야 한다.

  • 400번대 : 클라이언트측 오류
	  • 400 : 잘못된 요청.
	  • 401 : 권한없음.
	  • 403 (Forbidden) : 필요한 권한을 가지고 있지 않아서, 요청을 거부
	  • 404 : 서버에서 요청한 리소스를 찾을 수 없다.
	  • 405 : 허용되지 않는 방법. POST 방식만을 지원하는 뷰에 GET요청을 할 경우

  • 500번대 : 서버측 오류
	  • 500 : 서버 내부 오류 발생




지금까지 




8강
장고 쉘? (python interactive shell)
일반적인 쉘과 다르게 장고 프로젝트 설정이 로딩되어 있다.
뭔 소리냐? : 일반적인 쉘에는 장고 프로젝트의 초기 셋업 과정을 거치지 않으므로 이를 직접 거치지 않으면 접근이 불가능하다 (장고 환경변수, 장고 세팅, 장고 셋업, 프로젝트에 대한 리소스 접근 등을 먼저 해 두어야 한다)

실행 방법 : python manage.py shell
or django-extensions 내의 shell_plus 명령 : python manage.py shell_plus


이 장고 쉘은 왜 사용하냐?
	-> 결과를 계속 확인하면서 코드를 interactive하게 작성하기 위해
		-> 예시) SQL 출력

나중에 사용할 경우가 생기면 한번 직접 써보자
(주피터 노트북에서도 사용 가능 But 일부 불가능 할 수 있으니 확인 필요)
 ** 주피터 노트북? : 서버-클라이언트 환경에서 웹브라우저로 코딩하고 결과물까지 한화면에 볼수있는 편집기




9강 장고 모델 (ORM)

데이터 베이스?
장고는 데이터 베이스(RDBMS)로 데이터를 저장하고, 관리한다
RDBMS? : 관계형 데이터 베이스 관리 시스템
	MySQL, SQLite, Oracle 등이 존재
// NoSQL 시스템도 있긴 하지만 사용하지 않음
// RDBMS는 스키마(데이터 베이스의 고정된 데이터 형태)가 있고, NoSQL은 스키마가 없기 때문

데이터베이스에 쿼리(데이터를 관리)하기 위한 언어 : SQL
SQL? (Structured Query Language)
관계형 데이터베이스 관리 시스템(RDBMS)의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어
https://ko.wikipedia.org/wiki/SQL 참고


그래 그럼 이 SQL을 살 때 무엇을 조심해야 하지?
 	-> 같은 작업을 하더라도 보다 적은 수의 SQL, 보다 높은 성능의 SQL을 판단, 사용해야 한다.
	-> 일반적으로 직접 SQL을 만들지 않고 ORM을 통해 통해 SQL을 생성/ 실행한다.
ORM이란? (Object-relational mapping)
 -> 객체와 관계와의 설정. 
 -> 여기서 관계란? 데이터 베이스
 -> 즉, 객체와 데이터베이스와의 설정(맵핑)을 의미한다.
 -> 하지만 ORM을 쓰더라도 작성된 ORM코드를 통해 어떤 SQL이 실행되고 있는지 파악, 최적화 할 수 있어야 한다.

SQL과 DB의 차이?




















지금 까지의 흐름 
우린 이 장고 ORM을 통해 나만의 SQL을 만들어 RDBMS형태의 데이터베이스를 관리할 것이다,

장고 모델 이외의 ORM을 이용할 수 있지만 비추래
	// 왜냐하면 장고의 강점인 Model과 Form을 사용할 수 없기 때문!

 ** ORM, 장고 ORM, DB등 더 알아보자

Djagno Model (장고 내장 ORM)
  장고는 <DB 테이블>과 <파이썬 클래스>를 1:1로 매핑한다 
  이를 사용하기 위해 다음과 같은 조건을 만족해야 한다
	모델의 클래스명은 단수형으로
	매핑되는 모델 클래스와 DB 테이블 필드 내역이 일치해야 함
	모델을 만들기 전, 서비스와 맞게 데이터베이스 설계를 필수적으로 해야 함
	
	 ** DB에 공부가 더 필요하다

모델 활용 순서

Case1. 장고 모델을 통해, 데이터베이스 형상을 관리 (우리가 쓸것)
	1. 모델 클래스 작성
	2. 모델 클래스로부터 마이그레이션 파일 생성 (makemigrations 명령 사용)
	3. 마이그레이션 파일을 데이터베이스에 적용 (migrate 명령)
	4. 모델 활용 (불러오고 수정하고 등 ...)

Case2. 장고 외부에서, 데이터베이스 형상을 관리
	1. 데이터베이스로부터 모델 클래스 소스 생성 (inspectdb 명령)
	2. 모델 활용



결국 app의 models를 통해 장고 DB를 설정하고, 다른 파일(즉, view template)에서 app의 models를 통해 이 DB에 전근하는 것?




























	1. 학생회가 관리하는 거 (학생회 컴퓨터에서 파일을 수정?) 
		(웹 -> 학생회 컴퓨터 -> 웹) 
		(웹 -> DB) 

		(프로그램 -> 학생회 컴퓨터 -> 프로그램) 다음주 ‘월’까지

		웹 -> DB -> 웹
		웹 -> 학생회 컴퓨터 -> 웹
		웹 -> 엑셀 -> MFC

		MFC를 서비스를 하려면?
	웹 작업 -> MFC반영		DB -> Exel
	MFC 작업 -> 웹 반영		Excel -> DB

		Data type
			엑셀 
			DB “MFC프로그램으로 DB정보를 전달”
		

		학생회 컴퓨터의 엑셀 -> 웹으로 적용

		엑셀로서 남기기 위해선
			학생회 컴퓨터에 있는 DB-> 학생회 컴퓨터에 있는 엑셀
			MFC로 하면 어떻게든 되지 않을까? 

	2. 학우들이 사용하는 거
웹으로 굳이 만드는게 귀찮지 않냐?
어떤 18친구가 이거 민성 주도

2그룹 웹 + MFC(이걸 굳이?)








	





페이지1. db정보를 string 출력하기


장고 파일들이 회실컴에서, 서버가 돌아감?

장고폴더(db) = localhost127.0.0.1
mfc폴더

웹 만들고 -> 클라우드에 올리기.
	클라우드에서 구동

mfc하기 위해선
	local (자기 자신의 컴퓨터의 파일을 수정해서 반영하기)


실제 서비스를 하려면 mfc까지
	웹 만들고 -> 배포하고


일단 : local -> cloud (웹 서비스 가능, mfc 서비스 불가능)
local -> cloud -> 회실컴퓨터로 구동 (웹 서비스 가능, mfc 서비스 가능)

만약 불가능하다면
	mfc 헛수고지?
	기분 나쁘겠지?

c프로그램
	도서 관리프로그램
	서버에 올라가?
	local혼자서만 돈다는거잖아

excel파일이 아니라 sqlite3의 라이브러리를 다 알아서 해야한다.
sqlite3 -> excel이건 어떻게든 될거같음




	html 쪽 공부
		어떤게? : 태그속성?
		어떤게 

월요일?
화욜 대충 읽어 봐줄 수 있니?


설계
































장고가 기본 지원하는 모델 필드들 (커스텀 필드를 만드는 것도 가능하다)

그런데 이중에서 기본 키 primary key라는게 존재해서 궁금해서 찾아봤다.
이건 
= > 관계형 데이터베이스에서 조(레코드)의 식별자로 이용하기에 가장 적합한 것을 관계 (테이블)마다 단 한 설계자에 의해 선택, 정의된 후보 키를 말한다. 
=> primary key를 저장하는 필드인 auto field는 데이터베이스가 결정해주므로 직접 만질 필요는 없다

이런 모델필드들은 DB필드 타입을 반영한다
	-> DB에서 지원하는 필드를 반영한다 
(파이썬 입장에선 모든 Str은 모두 같은 str형 but DB의 경우 str은 다 고유의 성질을 가진 str형들이 있다)
	-> 따라서 파이썬 데이터 타입과 DB데이터 타입을 매핑한다
	    (AutoField -> int), (char, slug.... -> str)
	-> 같은 모델필드라고 할 지라도, DB에 따라 다른 타입으로 매핑되어 생성될 수 있기 때문에 이를 염두해 두어야 한다.

// 모델필드는 DB필드 타입 반영, 이렇게 반영된 DB 데이터 타입은 파이썬 데이터타입과 매핑되어 사용됨 
	** (모델필드로 모델을 작성하면 매핑된 파이썬 데이터타입으로 실행된다는 뜻?)




필드는 매우 다양하다. 
하지만 이를 str로만 설정한다면, 저장은 쉽지만, 입력 값 오류를 모두 다 직접 설정해주어야 한다. 따라서 설계한 데이터베이스 구조에 따라 최대한 필드 타입을 타이트 하게 해야한다.
ex) (year –x-> str), (year -> int)


자동 생성되는 id 필드?
	-> 각 row를 식별해주는 자동 생성된 primary key 타입의 필드
	-> 만약 자동 생성된 id필드 외에 다른 것을 갖고싶다면 다른 필드에 primary_key = true 옵션을 써주면 된다.

각 필드는 뿐만 아니라 속성또한 갖고 있다.
예를 들어 필드 값의 blank 허용 여부, 앞서 말했던 primary key 설정 등 다양한 옵션이 존재한다.
그중에는 필수 필드라는 옵션도 존재하는데, 이 부분에서 migration시, 데이터가 존재하지 않으므로 반드시 다른 필드의 값이 대치되거나, 설정을 바꿔야 한다.

협업 Tip
절대 하지말하야 할 일
	팀원 각자가 마이그레이션 파일을 생성 하면 DKSEHOSEK -> 충돌 발생
	추천 대안 : 마이그레이션 파일 생성을 1명이 전담해서 생성한다. (이렇게 생성된 마이그레이션 파일을 버전관리에 넣고, 다른 팀원은 이를 받아서 migrate만 수행)

반영하지 않은 마이그레이션을 다수 생성했다면? -> 하나의 마이그레이션으로 합쳐서 적용!
	방법1) 모든 마이그레이션들을 롤백하고, 마이그레이션들파일 제거후 새 마이그레이션 파일 생성 (이건 근데, 롤백될 때 값들도 함께 삭제되고, 자동복구도 안되므로 의도적인 방법으로 방법을 알아보자 [파이썬으로 뭐시기 저시기])
	방법2) squashmigrations로 미적용 마이그레이션들을 하나로 함치기








Migration -> 모델의 변경내역을 DB스키마로 반영시키는 방법
명령
	-0. ~~ == python manage.py
	-1. ~~ makemigrations <앱 이름>
	-2. ~~ migrate <앱 이름>
	-3. ~~ showmigrations <앱 이름>
	-4. sqlmigrate <앱이름> <마이그레이션-이름>














11강

amin page

장고엔 데이터를 관리할 수 있는 페이지인 admin page가 존재
default 경로의 url을 바꿔야 해킹에 안전,
django-admin-honeypot을 통해 가짜 admin 페이지를 노출하여 해킹 방해 가능
관리 초기에 데이터 관리에 적합하다 -> (superuser만 글을 쓸 경우)
	-> 관리 도구 만들 시간 대신 End-User 서비스에 집중하면 더 이득!



how to do?
  admin.py에 아이템에 대한 모델(즉, DB의 쿼리)를 사용하기 위해서 현재 모델의 itemp을 import해준다.
		->from .models import djang

  후에, admin.py에 이를 등록해준다
		->admin.site.register(Item) // 기본 ModelAdmin으로 동작한다
		->admin,site.register(Item, model_class)//지정한 ModelAdmin으로 동작
 		-> @admin.register(Item) // 2번과 같지만, 코딩이 더 명확하다
			calss Item model~~~~

	지정한 model class??
		-> 기본 모델 클래스에서 객체를 출력 시 object(1)이라는 문자열이 출력된다. 이를 모델클래스를 지정하고, 수정하여 객체의 “name”변수를 출력하도록 클래스를 지정, 등록할 수 있다.
		-> 뿐만 아니라 list_display를 통해 모델 리스트에 출력할 컬럼들을 지정할 수 있다.

** display_list_links를 통해서 필드에 링크를 넣을 수 있다, 
** search_fields를 통해 검색을 위한 필드를 지정할 수 있다.
** list_filter를 통해 필터를 위한 필드를 지정할 수 있다.








13강 모델을 위한 조회


Model Manager
  -> DB의 질의 인터페이스를 제공해주는 모델 메니저
  -> 디폴트 Manager(커스텀도 가능하지만 일단)로서 ModelCls.objects 제공된다.
	// 여기서 “ModelCls”는 모델의 이름이 대치된다.
  -> 이를 통해서 쿼리셋을 얻을 수도 있고, 정렬을 할 수도 값을 넣을 수도 있다.
 	// QuerySet? 

QuerySet? : SQL을 생성해주는 인터페이스이다.
  -> 순회 가능한 객체로, 순회를 통해 데이터에 접근할 수 있다.
  -> 쿼리셋은 Chianing을 지원한다
	(Item.objects.all) -> 쿼리셋 생성
	((Item.objects.all).filter()) -> 조건을 Chaining하여 새로운 쿼리셋 생성
	.... -> 쿼리셋 생성
  -> 쿼리셋은 Lazy한 특성을 갖는다
	* 즉, 쿼리셋을 만드는 동안 DB접근을 하지 않는다. (SQL도 이때 만들어 지는 것이 아니라, DB에 직접적으로 접근할 때 만들어 지는 것이다.)
 	* 데이터가 필요한 시점에 DB에 접근을 한다. (필요한 시점이 언제인진 아래를 보자)
		1. 출력
		2. list화 (즉, 리스트를 만들기 위해 값이 필요)
		3. 순회를 돌 경우 (for instance in queryset : ....)
			// 순회를 돌 때는 맨 처음만 DB를 접근하고 후엔 그걸 참조하여 동작한다.




