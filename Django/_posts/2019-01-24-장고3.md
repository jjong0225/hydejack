이전 포스팅 들에서 장고의 기본구조와 장고가 어떻게 유저의 요청을 응답하는지 배워봤다.   
이번 포스팅에선 유저의 요청에 응답할때 어떻게 DB의 데이터를 가져오는 방법에 대해서 알아보자   

## 장고 모델 (ORM)

1. 데이터 베이스   
  장고는 데이터 베이스(RDBMS)로 데이터를 저장하고, 관리한다
RDBMS? : 관계형 데이터 베이스 관리 시스템
	MySQL, SQLite, Oracle 등이 존재
// NoSQL 시스템도 있긴 하지만 사용하지 않음
// RDBMS는 스키마(데이터 베이스의 고정된 데이터 형태)가 있고, NoSQL은 스키마가 없기 때문

데이터베이스에 쿼리(데이터를 관리)하기 위한 언어 : SQL
SQL? (Structured Query Language)
관계형 데이터베이스 관리 시스템(RDBMS)의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어
https://ko.wikipedia.org/wiki/SQL 참고


그래 그럼 이 SQL을 살 때 무엇을 조심해야 하지?
 	-> 같은 작업을 하더라도 보다 적은 수의 SQL, 보다 높은 성능의 SQL을 판단, 사용해야 한다.
	-> 일반적으로 직접 SQL을 만들지 않고 ORM을 통해 통해 SQL을 생성/ 실행한다.
ORM이란? (Object-relational mapping)
 -> 객체와 관계와의 설정. 
 -> 여기서 관계란? 데이터 베이스
 -> 즉, 객체와 데이터베이스와의 설정(맵핑)을 의미한다.
 -> 하지만 ORM을 쓰더라도 작성된 ORM코드를 통해 어떤 SQL이 실행되고 있는지 파악, 최적화 할 수 있어야 한다.


지금 까지의 흐름 
우린 이 장고 ORM을 통해 나만의 SQL을 만들어 RDBMS형태의 데이터베이스를 관리할 것이다,

장고 모델 이외의 ORM을 이용할 수 있지만 비추래
	// 왜냐하면 장고의 강점인 Model과 Form을 사용할 수 없기 때문!

 ** ORM, 장고 ORM, DB등 더 알아보자

Djagno Model (장고 내장 ORM)
  장고는 <DB 테이블>과 <파이썬 클래스>를 1:1로 매핑한다 
  이를 사용하기 위해 다음과 같은 조건을 만족해야 한다
	모델의 클래스명은 단수형으로
	매핑되는 모델 클래스와 DB 테이블 필드 내역이 일치해야 함
	모델을 만들기 전, 서비스와 맞게 데이터베이스 설계를 필수적으로 해야 함
	
	 ** DB에 공부가 더 필요하다

모델 활용 순서

Case1. 장고 모델을 통해, 데이터베이스 형상을 관리 (우리가 쓸것)
	1. 모델 클래스 작성
	2. 모델 클래스로부터 마이그레이션 파일 생성 (makemigrations 명령 사용)
	3. 마이그레이션 파일을 데이터베이스에 적용 (migrate 명령)
	4. 모델 활용 (불러오고 수정하고 등 ...)

Case2. 장고 외부에서, 데이터베이스 형상을 관리
	1. 데이터베이스로부터 모델 클래스 소스 생성 (inspectdb 명령)
	2. 모델 활용



결국 app의 models를 통해 장고 DB를 설정하고, 다른 파일(즉, view template)에서 app의 models를 통해 이 DB에 전근하는 것?



장고가 기본 지원하는 모델 필드들 (커스텀 필드를 만드는 것도 가능하다)

그런데 이중에서 기본 키 primary key라는게 존재해서 궁금해서 찾아봤다.
이건 
= > 관계형 데이터베이스에서 조(레코드)의 식별자로 이용하기에 가장 적합한 것을 관계 (테이블)마다 단 한 설계자에 의해 선택, 정의된 후보 키를 말한다. 
=> primary key를 저장하는 필드인 auto field는 데이터베이스가 결정해주므로 직접 만질 필요는 없다

이런 모델필드들은 DB필드 타입을 반영한다
	-> DB에서 지원하는 필드를 반영한다 
(파이썬 입장에선 모든 Str은 모두 같은 str형 but DB의 경우 str은 다 고유의 성질을 가진 str형들이 있다)
	-> 따라서 파이썬 데이터 타입과 DB데이터 타입을 매핑한다
	    (AutoField -> int), (char, slug.... -> str)
	-> 같은 모델필드라고 할 지라도, DB에 따라 다른 타입으로 매핑되어 생성될 수 있기 때문에 이를 염두해 두어야 한다.

// 모델필드는 DB필드 타입 반영, 이렇게 반영된 DB 데이터 타입은 파이썬 데이터타입과 매핑되어 사용됨 
	** (모델필드로 모델을 작성하면 매핑된 파이썬 데이터타입으로 실행된다는 뜻?)




필드는 매우 다양하다. 
하지만 이를 str로만 설정한다면, 저장은 쉽지만, 입력 값 오류를 모두 다 직접 설정해주어야 한다. 따라서 설계한 데이터베이스 구조에 따라 최대한 필드 타입을 타이트 하게 해야한다.
ex) (year –x-> str), (year -> int)


자동 생성되는 id 필드?
	-> 각 row를 식별해주는 자동 생성된 primary key 타입의 필드
	-> 만약 자동 생성된 id필드 외에 다른 것을 갖고싶다면 다른 필드에 primary_key = true 옵션을 써주면 된다.

각 필드는 뿐만 아니라 속성또한 갖고 있다.
예를 들어 필드 값의 blank 허용 여부, 앞서 말했던 primary key 설정 등 다양한 옵션이 존재한다.
그중에는 필수 필드라는 옵션도 존재하는데, 이 부분에서 migration시, 데이터가 존재하지 않으므로 반드시 다른 필드의 값이 대치되거나, 설정을 바꿔야 한다.

협업 Tip
절대 하지말하야 할 일
	팀원 각자가 마이그레이션 파일을 생성 하면 DKSEHOSEK -> 충돌 발생
	추천 대안 : 마이그레이션 파일 생성을 1명이 전담해서 생성한다. (이렇게 생성된 마이그레이션 파일을 버전관리에 넣고, 다른 팀원은 이를 받아서 migrate만 수행)

반영하지 않은 마이그레이션을 다수 생성했다면? -> 하나의 마이그레이션으로 합쳐서 적용!
	방법1) 모든 마이그레이션들을 롤백하고, 마이그레이션들파일 제거후 새 마이그레이션 파일 생성 (이건 근데, 롤백될 때 값들도 함께 삭제되고, 자동복구도 안되므로 의도적인 방법으로 방법을 알아보자 [파이썬으로 뭐시기 저시기])
	방법2) squashmigrations로 미적용 마이그레이션들을 하나로 함치기


Migration -> 모델의 변경내역을 DB스키마로 반영시키는 방법
명령
	-0. ~~ == python manage.py
	-1. ~~ makemigrations <앱 이름>
	-2. ~~ migrate <앱 이름>
	-3. ~~ showmigrations <앱 이름>
	-4. sqlmigrate <앱이름> <마이그레이션-이름>




11강

amin page

장고엔 데이터를 관리할 수 있는 페이지인 admin page가 존재
default 경로의 url을 바꿔야 해킹에 안전,
django-admin-honeypot을 통해 가짜 admin 페이지를 노출하여 해킹 방해 가능
관리 초기에 데이터 관리에 적합하다 -> (superuser만 글을 쓸 경우)
	-> 관리 도구 만들 시간 대신 End-User 서비스에 집중하면 더 이득!



how to do?
  admin.py에 아이템에 대한 모델(즉, DB의 쿼리)를 사용하기 위해서 현재 모델의 itemp을 import해준다.
		->from .models import djang

  후에, admin.py에 이를 등록해준다
		->admin.site.register(Item) // 기본 ModelAdmin으로 동작한다
		->admin,site.register(Item, model_class)//지정한 ModelAdmin으로 동작
 		-> @admin.register(Item) // 2번과 같지만, 코딩이 더 명확하다
			calss Item model~~~~

	지정한 model class??
		-> 기본 모델 클래스에서 객체를 출력 시 object(1)이라는 문자열이 출력된다. 이를 모델클래스를 지정하고, 수정하여 객체의 “name”변수를 출력하도록 클래스를 지정, 등록할 수 있다.
		-> 뿐만 아니라 list_display를 통해 모델 리스트에 출력할 컬럼들을 지정할 수 있다.

** display_list_links를 통해서 필드에 링크를 넣을 수 있다, 
** search_fields를 통해 검색을 위한 필드를 지정할 수 있다.
** list_filter를 통해 필터를 위한 필드를 지정할 수 있다.




13강 모델을 위한 조회


Model Manager
  -> DB의 질의 인터페이스를 제공해주는 모델 메니저
  -> 디폴트 Manager(커스텀도 가능하지만 일단)로서 ModelCls.objects 제공된다.
	// 여기서 “ModelCls”는 모델의 이름이 대치된다.
  -> 이를 통해서 쿼리셋을 얻을 수도 있고, 정렬을 할 수도 값을 넣을 수도 있다.
 	// QuerySet? 

QuerySet? : SQL을 생성해주는 인터페이스이다.
  -> 순회 가능한 객체로, 순회를 통해 데이터에 접근할 수 있다.
  -> 쿼리셋은 Chianing을 지원한다
	(Item.objects.all) -> 쿼리셋 생성
	((Item.objects.all).filter()) -> 조건을 Chaining하여 새로운 쿼리셋 생성
	.... -> 쿼리셋 생성
  -> 쿼리셋은 Lazy한 특성을 갖는다
	* 즉, 쿼리셋을 만드는 동안 DB접근을 하지 않는다. (SQL도 이때 만들어 지는 것이 아니라, DB에 직접적으로 접근할 때 만들어 지는 것이다.)
 	* 데이터가 필요한 시점에 DB에 접근을 한다. (필요한 시점이 언제인진 아래를 보자)
		1. 출력
		2. list화 (즉, 리스트를 만들기 위해 값이 필요)
		3. 순회를 돌 경우 (for instance in queryset : ....)
			// 순회를 돌 때는 맨 처음만 DB를 접근하고 후엔 그걸 참조하여 동작한다.




